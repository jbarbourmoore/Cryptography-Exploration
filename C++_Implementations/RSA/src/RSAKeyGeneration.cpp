/// This file handles generation of RSA Keys in C++
///
/// Libaries Used : OpenSSL BIGNUM for dealing with extremely large integers
/// Author        : Jamie Barbour-Moore
/// Created       : 05/12/25
/// Updated       : 05/13/25

#include "RSAKeyGeneration.hpp"

RSAKeyGeneration::RSAKeyGeneration(int keylength){
    keylength_ = keylength;

    setEParameters();
    setMinPQDiff();
    setMinPrimeValue();
}

void RSAKeyGeneration::generateRSAKeysUsingProvablePrimes(){
    // generate a random public exponent
    generateRandomE();
    char *hex_e = BN_bn2hex(e_);
    printf("The value of e is %s\n", hex_e);
    OPENSSL_free(hex_e);

    // generate a random seed
    generateRandomSeed();
    char *hex_seed = BN_bn2hex(seed_);
    printf("The value of seed is %s\n", hex_seed);
    OPENSSL_free(hex_seed);

    constructTheProvablePrimes();
}

void RSAKeyGeneration::generateRandomE(){
    int security_strength = getSecurityStrength();

    BIGNUM *random = BN_new();

    int bits = 256 - 16;

    // generate the random value in the range
    int success = BN_rand_ex(random, bits, BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ODD, security_strength, context_);

    assert(success == 1);

    // add the random value to e_min
    BN_add(e_, random, e_min_);

    BN_free(random);
}

bool RSAKeyGeneration::constructTheProvablePrimes(){

    char* hex_first_seed = BN_bn2hex(seed_);

    ProvablePrimeGenerationResult result = constructAProvablePrimePotentiallyWithConditions(getPrimeLength(), 1, 1, hex_first_seed);

    if (result.success != true) {
        printf("Failed to construct provable prime 'p'\n");
        return false;
    }else {
        printf("prime hex : %s\n", result.prime);
    }
    
    return false;
};

ProvablePrimeGenerationResult RSAKeyGeneration::constructAProvablePrimePotentiallyWithConditions(int L, int N1, int N2, char* first_seed_char){
    ProvablePrimeGenerationResult result = ProvablePrimeGenerationResult{};

    BIGNUM *first_seed = BN_new();
    BN_hex2bn(&first_seed, first_seed_char);

    // generate an auxillary prime of length N1
    int p1 = 0;
    BIGNUM *p2_seed = BN_new();
    if (N1 == 1){
        p1 = 1;
        BN_copy(p2_seed, first_seed);
    } else {
        assert(N1 == 1);
    }

    // generate an auxillary prime of length N2
    int p2 = 0;
    BIGNUM *p0_seed = BN_new();
    if (N2 == 1){
        p2 = 1;
        BN_copy(p0_seed, p2_seed);
    } else {
        assert(N2 == 1);
    }

    int length = L/2;
    if (L % 2 != 0) {
        length += 1;
    }

    ShaweTaylorRandomPrimeResult shawe_taylor_result = generateRandomPrimeWithShaweTaylor(length, p0_seed);


    return result;
};

BIGNUM* RSAKeyGeneration::hashBigNum(BIGNUM* bignum_to_hash){
    BIGNUM *hash_result = BN_new();

    size_t size = BN_num_bytes(bignum_to_hash);
    unsigned char *value_to_hash = new unsigned char[size]();
    
    BN_bn2bin(bignum_to_hash, value_to_hash);

    EVP_MD_CTX *hash_context = EVP_MD_CTX_new();
    EVP_DigestInit_ex(hash_context, EVP_sha512(), NULL);

    EVP_DigestUpdate(hash_context, value_to_hash, size);

    unsigned hash_length_bytes = hash_length_/8;
    unsigned char hash_result_bytes[hash_length_/8];

    EVP_DigestFinal_ex(hash_context, hash_result_bytes, &hash_length_bytes);
    EVP_MD_CTX_free(hash_context);

    BN_bin2bn(hash_result_bytes, hash_length_bytes, hash_result);

    char *hash_result_hex = BN_bn2hex(hash_result);
    printf("hash : %s\n", hash_result_hex);

    return hash_result;
};

ShaweTaylorRandomPrimeResult RSAKeyGeneration::generateRandomPrimeWithShaweTaylor(int length, BIGNUM* input_seed){
    ShaweTaylorRandomPrimeResult result {};
    BIGNUM *prime_seed = input_seed;
    BIGNUM *number_one = BN_new();
    const char *hex_one = "1";
    BIGNUM *number_two = BN_new();
    const char *hex_two = "2";

    BN_hex2bn(&number_one,hex_one);
    printf("starting shawe taylor\n");
    BIGNUM *hash_prime_seed = hashBigNum(prime_seed);
    BIGNUM *inc_seed = BN_new();
    BN_add(inc_seed, prime_seed, number_one);
    BIGNUM *hash_inc_seed = hashBigNum(inc_seed);

    BIGNUM *c = BigNumHelpers::xorBigNums(hash_prime_seed, hash_inc_seed);
    
    int length_minus_1 = length - 1;

    return result;
};


void RSAKeyGeneration::generateRandomSeed(){
    int security_strength = getSecurityStrength();
    int length = 2 * security_strength + 1;
    int success = BN_rand_ex(seed_, length, BN_RAND_TOP_ANY,BN_RAND_BOTTOM_ANY,security_strength,context_);
    assert(success == 1);
}

void RSAKeyGeneration::setEParameters(){
    // the max and min values for e as a hexadecimal string
    const char *hex_e_min = "010000";
    const char *hex_e_max = "010000000000000000000000000000000000000000000000000000000000000000";

    // set them to BIGNUM
    BN_hex2bn(&e_min_, hex_e_min);
    BN_hex2bn(&e_max_, hex_e_max);
}

void RSAKeyGeneration::setMinPrimeValue(){
    const char *hex_min_prime = "0";
    if (keylength_ == 2048) {
        hex_min_prime = "B504F333F9DE68000000000D69DD51BA07CF0930728CA984CB424FC1B7692DDBFB70A9E5D469EADD536D45398DBBCD6022779634136D29612502CB8F6F04FB3B56A2928A53073CE3978083009F5EA4E0769E4764B0DD62D32B887102580000000000000000000000000000000000000000000000000000000000000000000000";
    } else if (keylength_ == 3072) {
        hex_min_prime = "B504F333F9DE68000000000D7D4F8EC5E6F9B24422D017252D192AF704E153170ADAD97CC0E577EA17BBCCAC3B5D45DC7BBF091F9F7689FB695C4090112C398E9DEA1F7542D12CFD4C15C4C470EC669C40F3A44756C31D6DE70D14567EE58B317033D483B06CEF75B304CCAC47969D0B855F372238BFCCDBC693CE1379C972302BF4C903C0079A203498000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    } else if (keylength_ == 7680) {
        hex_min_prime = "B504F333F9DE680000000002DBCC5944D29679C6B026782D549D7DCCF5262B98E3380803F98DE79154E014E4C1AF8C4C4195882D2CAA63D6DB99C5EAF54D05E6F2129440E66D0B3F91D35C72633EBC00E65D69D7AEFA055325B0BA383F52489054F54B8A6DCB0A9412E234D861834749F74DF80CCDCF08019F7C16ADDC5124B3ECA3588FB07A40CC680FF498A0F377D9AE6B00152C97AE8733B7CD205E6640A62D4F1CE8B28CE40E10D981DAF45AAF4967D4BB6315D887EB80DED69A8461FB5C49B3FCB0C23450F625C77E3FCBE5854E8E51B3051018FD4F2A4EB17890AB7F2C0B0739BF37D60AFAC3861F20D20BB27FBEEF685D738CA0E199C9D32677F23485233D57FE17E4D57639BC8C5642EBE6A37BCF06C6BE25C0CA755EE3FB0DB90AA5559E45F8997D1F0443D70320541210A7E143E02BE39BB5C742CBEEDB04F87A0E88BE86DB98FC4B0E0F0186C0032979B8CF479B000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    } else if (keylength_ == 15360){
        hex_min_prime = "B504F333F9DE67FFFFFFFFFECF09E99863EFFE0BD0AA9D1F60903DFA4EED6F77C50A7E35CE10A18FA81A5AEC7B5EAE72792308005139A883364CAA573DB390221C62D2C5EE34B0CFE28A3FF00846327292B6DC7BF0F0393B0B3B53ABBE7A21859AEAD2FA3A23433043B3BA7FDE39368AF5538145BBE5104D0B32D50A2BE65618D6E99E8C160C39D01CA36EA3684527AE13BA83A0DB32C27D31EBDA8778EE3C591815E02F3C3543B5EB66D3B3EDB5E8600F85B6D694C980145451E9477845203F1EB2ADD3D6349D0FB70027DCFE0A11DAC6EA64ADE77317F743D28E859561F93D7E16651C275ACC78D7257AE4095CA3D68DFAD533CDE7A0D6F66CA543BBC984595980CCA4DAAE3EF538DA716BC41A1705034112D4B762D74084D95BB2CCB7967426DBAFDCF8A9AA1072946D7C24E7C53C1D5D99DF4B8E0AE25810E9931017D9C8A3F47B3284DD5A2EE6D0737B43E1CD98B4E43CC4AEF208688BA370AC68692A728CD5EBD545B5A1C4ADE7CC3F16DD1643CC4F2E515698F65523ABE1DE038E4469216E6BEA3CE6F5C1F3A4F111A7FB2E5253526B74B18BAC1465E9709E625830F4CB715DE01E0CBF7D45F53BCE4E07A8A25870CF4EC842E8318D5838D069C3181290BA1936E4D064AB91F47EEBA8363F8A6A8B73D195D13238FCB5929D88433EDD6126E142B271278D1882DB0F1B4646D5984426678643F918B6A464DB914D25D4681AF0E753F8C5016467393A419C9A3B72B3174C9C186A182B4A7F7F928CC73EB738254732048D5225E96E451454201418FD4E813EEB58BEF28668566A23FCE0E15635E38728585A2EC0F111DE326313C96BE6D63B1239206AC77CAC0D936BE8160878A2FA5906DC6020FECB4CDD4B65ED87B5B25F14549F0486FF6B89074CFBDBEE61F5F3245A819BF1206D6796DC9C72F400147D73E8CF7B1EAF30BCB39F15F955F0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    }
    BN_hex2bn(&min_prime_value_, hex_min_prime);
}

void RSAKeyGeneration::setMinPQDiff(){
    const char *hex_min_diff = "0";
    if (keylength_ == 2048) {
        hex_min_diff = "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    } else if (keylength_ == 3072) {
        hex_min_diff = "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    } else if (keylength_ == 7680) {
        hex_min_diff = "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    } else if (keylength_ == 15360){
        hex_min_diff = "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    }
    BN_hex2bn(&min_pq_diff_, hex_min_diff);
}

int RSAKeyGeneration::getSecurityStrength(){
    int security_strength = 0;
    if (keylength_ == 2048) {
        security_strength = 112;
    } else if (keylength_ == 3072) {
        security_strength = 128;
    } else if (keylength_ == 7680) {
        security_strength = 192;
    } else if (keylength_ == 15360){
        security_strength = 256;
    }
    return security_strength;
};

int RSAKeyGeneration::getKeyLength(){
    return keylength_;
};

int RSAKeyGeneration::getPrimeLength(){
    return keylength_ / 2;
};