# Cryptography Exploration With C++ Graphical User Interface
This folder contains the information for my C++ implementations while exploring cryptography. The GUI applicaton was created using QT. The RSA implementation relies upon OPENSSL for big number handling and random number generation only. Unit tests were created using the GTest framework.

<img 
    style="display: block; margin-left: auto; margin-right: auto; width: 100%;"
    src="https://github.com/jbarbourmoore/Cryptography-Exploration/blob/0a5b12a1dcd05a0785b3af13584fc09e29bb1590/CryptographySchemes/OutputImages/C%2B%2BGuiApplication.jpg" 
    alt="This is screenshots from the C++ GUI application. It shows the use of C++ to generate RSA Keys and use them to both encrypt and decrypt simple hexadecimal strings. The other image shows the use of SHA1 and SHA2 to create hash digests of the string input.">
</img>  

## Table of Contents
1. RSA Cryptography Scheme - [README Section](#rsa-cryptography-scheme) - [C++ Code](https://github.com/jbarbourmoore/Cryptography-Exploration/tree/8b6984fe2783e544e4cbff22bdc1420a83d6e633/C%2B%2B_Implementations/RSA/src) - [C++ Tests](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/8b6984fe2783e544e4cbff22bdc1420a83d6e633/C%2B%2B_Implementations/Tests/RSATests/src/EncryptionPrimitiveTests.cpp)
    1. RSA Key Generation - [README Section](#rsa-key-generation) - [C++ Code](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/8b6984fe2783e544e4cbff22bdc1420a83d6e633/C%2B%2B_Implementations/RSA/src/RSAKeyGeneration.cpp) - [C++ Tests](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/8b6984fe2783e544e4cbff22bdc1420a83d6e633/C%2B%2B_Implementations/Tests/RSATests/src/KeyGenTests_ProbablyPrime.cpp)
    2. RSA Private Key Forms - [README Section](#rsa-private-key-forms) - [C++ Code](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/8b6984fe2783e544e4cbff22bdc1420a83d6e633/C%2B%2B_Implementations/RSA/src/RSAPrivateKey.cpp) - [C++ Tests](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/8b6984fe2783e544e4cbff22bdc1420a83d6e633/C%2B%2B_Implementations/Tests/RSATests/src/KeyGenTests_ProbablyPrime.cpp)
2. Hashing Algorithms - [README Section](#hashing-algorithms)
     1. Secure Hash Algoithm 1 (SHA1) - [README Section](#secure-hash-algoithm-1-sha1) - [C++ Code](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/main/C%2B%2B_Implementations/HashingAlgorithms/src/SHA1.cpp) - [C++ Tests](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/main/C%2B%2B_Implementations/Tests/HashingTests/src/SHA1_tests.cpp)
    2. Secure Hash Algorithm 2 (SHA2) - [README Section](#secure-hash-algorithm-2-sha2) - [C++ Code](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/main/C%2B%2B_Implementations/HashingAlgorithms/src/SHA256.cpp) - [C++ Tests](https://github.com/jbarbourmoore/Cryptography-Exploration/blob/0a5b12a1dcd05a0785b3af13584fc09e29bb1590/CryptographySchemes/UnitTest/SHA2_UnitTests.py)

## RSA Cryptography Scheme  

I have implemented a version of the RSA Cryptography scheme in C++. RSA was named after R.L. Rivest, A. Shamir, and L. Adleman who laid out the system in their paper ["A Method for Obtaining Digital Signatures and Public-Key Cryptosystems"](https://people.csail.mit.edu/rivest/Rsapaper.pdf) from 1977. It relies on the difficulty in factoring large primes in order to prevnt people from breaking the security, and it is no longer particularly secure today, due to advancements in computing. When using RSA to encrypt messages each participant generates a private a public key. The message is sent using the recipient's public key and can then be decrypted using their private key. RSA keys are generated by first generating two large prime numbers, p and q. These prime numbers are mulitplied together in order to calculate n which is part of the public key. d and e are calculated with the help of the extended form of euclids algorithm such that when encrypting with the public key e and n, the public key d and n may be used to decrypt.    

### RSA Key Generation

RSA Cryptography relies on pairs of public and private keys that are created using two large prime numbers. NIST FIPS 186-5 ["Digital Signature Standard (DSS)"](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf) lays out multiple methods by which these prime numbers may be generated. The include Appendix A.1.2 "Generation of Random Primes that are Provably Prime", Appendix A.1.3 "Generation of Random Primes that are Probably Prime", Appendix A.1.4 "Generation of Provable Primes with Conditions Based on Auxiliary Provable Primes", A.1.5 "Generation of Probable Primes with Conditions Based on Auxiliary Provable Primes" and Appendix A.1.6 "Generation of Probable Primes with Conditions Based on Auxiliary Probable Primes". The bit lengths for the keys are also specified in NIST SP 800-57 Part 1 ["Recommendation for Key Management: Part 1 â€“ General"](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf) Table 2: "Comparable security strengths of symmetric block cipher and asymmetric-key algorithms". RSA or other integer factorization algorithms are listed by "k", the bit length of the "n" value, or the two primes multiplied together. For a security strength of 112 (equivalent to TDES), "k" must be 2048, for a security strength of 128 (equivalent to AES 128) "k" must be 3072, for a security strength of 192 (equivalent to AES 192) "k" must be 7680, and for a security strength of 256 (equivalent to AES 256) "k" must be 15360. Generating these extremely large primes does cause my computer to take a long time, though I admit freely that none of my implementations are designed for efficiency. I still think it is interesting to view the comparisons of the running times for each prime generation method depending on programming language and key length.

#### C++ Durations

<img 
    style="display: block; margin-left: auto; margin-right: auto; width: 100%;"
    src="https://github.com/jbarbourmoore/Cryptography-Exploration/blob/8ab2c9fa1fa2a755bc7ffb7005982704b671f248/CryptographySchemes/OutputImages/RSA_KeyGeneration_DurationGraphs_Cpp.png" 
    alt="This shows the key generation duration for each prime generation methodology over the various key lengths.">
</img>

### RSA Private Key Forms

As mentioned in NIST FIPS 186-5 ["Digital Signature Standard (DSS)"](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf) and IETF 8017 "PKCS #1: RSA Cryptography Specifications Version 2.2", there are actually two ways to store the private key. The first way is simply the "n" value or the multiple of the two large prime numbers, and the private exponent, "d". The second way uses a quintuple form and can increase the efficiency when decrypting data. The quintuple consists of both large prime numbers ("p" and "q"), the private exponent mod "p" and "q" ("dP" and "dQ"), as well as "qInv", or the inverse of "q" mod "p". The following graphs show the difference in time for both the standard and quintuple forms for decryption, though it does really not effect encrytion or key generation times.

#### C++ Durations

<img 
    style="display: block; margin-left: auto; margin-right: auto; width: 100%;"
    src="https://github.com/jbarbourmoore/Cryptography-Exploration/blob/8ab2c9fa1fa2a755bc7ffb7005982704b671f248/CryptographySchemes/OutputImages/RSA_KeyGeneration_DurationGraphs_Simple_Cpp.png" 
    alt="This shows the comparison between standard and quintuple private key forms during generation, encryption and decryption.">
</img>

## Hashing Algorithms

### Secure Hash Algoithm 1 (SHA1)  

I implemented a version of the SHA1 hashing algorithm as laid out in NIST FIPS 180-4, ["Secure Hash Standard (SHS)"](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf). SHA1 was developed by the United States National Security Agency(NSA) and was originally published in 1995. It is no longer considered secure. The SHA1 algorithm consists of a few functions that are run on 32 bit words, particularly ch, parity and maj, as well as bitwise operations including xor, and, shift and rotate. It produces a 160 bit hashdigest and can be quite prone to hash collisions compared to the other SHA algorithms.

### Secure Hash Algorithm 2 (SHA2)    

#### (SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256)    

I implemented versions of the SHA2 hashing algorithms as laid out in NIST FIPS 180-4, ["Secure Hash Standard (SHS)"](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf). Much like SHA1, SHA2 was initial developed by the NSA and was published in 2001. SHA2 is really a collection of algorithms with varying hash digest lengths that are built upon some of the characteristics of SHA1. Particularly, SHA-256 also rely upon the use of the ch and maj functions on 32 bit words, though they do not use the parity function and also add sigma functions. SHA-512 builds on the foundations of the SHA-256 functions, however it uses them on 64-bit words. The other algorithms within the SHA2 family all are strongly connected with either SHA-256 or SHA-512. SHA-224 has different starting hash values than SHA-256 and truncates the ouput to 224 bit, but otherwise is the same internally. SHA-384, SHA-512/224 and SHA-512/256 share a similar relationship with SHA-512. I used the GTest framework to create unit tests showing that the SHA1 and SHA2 implementations accurately produce the results provided by NIST in their [Cryptographic Standards and Guidelines: Example Values](https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values).